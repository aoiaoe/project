
rabbitmq 使用死信交换机和死信队列实现延迟任务会有bug
队头阻塞问题
假设消息1延迟20秒进行消费，消息2延迟10秒进行消费
但是消息1在队首，会先等到判断1过期之后，才会再去判断消息2是否过期


~~~tex
消息1(延迟20秒)  消息2(延迟10秒)， 入队顺序: 1 -> 2
预想的消费顺序： 10秒钟后消费消息2   20秒钟后消费消息1
实际的消费顺序： 20秒钟后消费消息1   然后马上消费消息2

入队顺序： 2 -> 1
没问题
~~~

原因： 由于rabbitmq消息过期实现方式的问题，只有消息到达队首才会去判断是否过期
https://www.rabbitmq.com/ttl.html#per-message-ttl-caveats
~~~text
Queues that had a per-message TTL applied to them retroactively (when they already had messages) 
will discard the messages when specific events occur. Only when expired messages reach the head 
of a queue will they actually be discarded (or dead-lettered). 
Consumers will not have expired messages delivered to them. 
Keep in mind that there can be a natural race condition between message expiration and consumer delivery, 
e.g. a message can expire after it was written to the socket but before it has reached a consumer.
~~~





